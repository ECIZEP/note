# 第三讲　启动、终端、异常和系统调用

## BIOS的启动

当系统加电，CPU完成初始化后，会进入BIOS固件系统（此时的ＣＰＵ处于实模式下），在CPU初始化的时候，有一个约定，要给ＣＳ：ＩＰ寄存器一个默认的值，这个值来决定我们从内存中读数据的位置。

ＢＩＯＳ固件系统启动的时候，会提供一些基本的服务来完成上面读数据的功能：

* 基本输入输出的程序（可以在内存或者其他设备上读数据，可以显示数据在显示器上）
* 系统设置信息（ＢＩＯＳ设置信息，比如说从哪个设备上启动操作系统，优先级顺序）
* 开机后的自检程序
* 系统自启动的程序


基本的流程如下：

**BIOS：**

1. 设置CS:IP的初始值为`0000:7c00`
2. 从磁盘的引导扇区把加载程序加载到内存的`0x07c00`(也就是第一步里面设置的CS:IP的初始值，这样CPU就可以从内存取指令开始执行加载程序)

**加载程序：**

1. 将操作系统的代码和数据从硬盘中加载到内存中
2. 跳转到操作系统的起始地址（操作系统内核的代码）

>为什么BIOS不直接将初始化的CS:IP值设置为操作系统的起始地址呢？
>
>
>
>解释：因为磁盘的文件系统是多样的，BIOS没有那么大的空间写很多代码去识别所有的文件系统，所以只能规定在一个固定的地址（`0x07c00`）去加载磁盘引导扇区的加载程序，然后文件系统的识别交给加载程序，这样可以灵活的加载操作系统

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161205/214851324.png)

## 系统的启动流程

但是现实的计算机的磁盘上会有多个分区，每个分区可能都有一个操作系统，所以需要加一个主引导记录去选择启动哪个分区的操作系统，所以将系统的启动进一步细化就是：

1. 系统加电，BIOS和CPU等硬件的初始化
2. 主引导记录，BIOS读取主引导扇区代码
3. 活动分区，主引导扇区代码再去读取活动分区的引导扇区代码
4. 加载程序（Bootloader） 引导扇区代码读取文件系统的加载程序
5. 启动菜单，可选的操作系统的列表和加载参数（正常启动/安全模式启动/调试模式启动）
6. 根据配置加载指定的内核并转到内核执行

**每一步的详细过程如下：**

其中第一步的CPU初始化：

* CPU加电稳定后，会从`0xFFFF0`读第一条指令，并且第一条指令是跳转指令，这个跳转到BIOS代码去执行

  ```
  CS:IP = 0XF000:FFF0
  ```

* CPU的初始状态为16位的实模式

BIOS的初始化：

* 硬件自检POST
* 检测系统中内存和显卡等关键部件的存在和工作状态
* 查找执行显卡等接口的BIOS，进行外设设备的初始化
* 进行系统BIOS，进行系统检测，检测和配置系统中安装的即插即用的设备
* 按指定的启动顺序从软盘或者磁盘或者U盘去读第一块引导扇区，把`512字节`的主引导记录加载到内存的`0x7c00`

这样就进入了主引导记录中，以`MBR`格式为例子

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161205/221148960.png)

主引导记录只有`512字节`，其中硬盘分区表只有64个字节，这也是为什么以前的`MBR`格式分区的磁盘最多只能有4个分区的原因

然后就从主引导记录的启动代码跳转活动分区的引导扇区

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161205/221501835.png)

引导扇区的引导记录的第一条指令是一个跳转到启动代码的跳转指令， 这里的启动代码因为是从硬盘里面加载进来的，所以可以将加载程序放到任意的地方，只要在启动代码里面做跳转，让CPU去执行加载程序,也叫`Bootloader`

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161205/222028628.png)

## 系统启动规范

> BIOS-MBR格式分区只能有四个分区，所以后来发展了BIOS-GPT（Globally Unique Identifier Partition Table Format），可以不受四个分区的限制
>
> 后来又定义了一种新的启动规范叫做UEFI，目的是为了在所有不同的平台上提供统一致的操作系统启动服务统一的可扩展固件接口(Unified Extensible Firmware Interface)，增加了一个可信性检查，提高安全性

## 中断、异常和系统调用比较

**系统调用(System Call)**：应用程序主动向操作系统发出的服务请求

**异常（Exception）:**非法指令或者其他原因导致当前指令执行失败

**中断（hardware interrupt）:** 来自硬件设备的处理请求

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161205/224505431.png)

|      | 中断           | 异常          | 系统调用       |
| ---- | ------------ | ----------- | ---------- |
| 源头   | 外设           | 应用程序的错误     | 应用程序主动要求服务 |
| 响应方式 | 异步           | 同步          | 异步或同步      |
| 处理机制 | 对用户来说没感觉，透明的 | 会杀死当前程序或者重启 | 等待和持续      |

### 系统调用

**外部的使用：**

* 操作系统服务的编程接口，一般通过高级接口编写（c/c++）
* 程序访问系统调用（例如输出字符串在显示屏上）都是通过高层次的API（c的标准库之类的）而不是直接进行系统调用
* 三种常用的编程应用程序编程接口
  1. Win32 API——Windows
  2. POSIX API用于POSIX-based system(包括UNIC,Linuc,Mac OS X的所有版本)
  3. Java API用于虚拟机JVM

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161206/164805215.png)

**内部的实现：**

*  每一个系统调用都对应一个系统调用的编号，应用程序软中断后会跳入系统调用表，然后去调到相应的系统调用程序去返回系统调用的结构
*  用户不知道系统调用的实现，系统调用的是在内核态里面进行的，不过用户需要设置调用的参数

**系统调用和函数调用的不同：**

* `INT`和`IRET`指令用于系统调用（实际上是中断的指令，然后再跳到系统调用表）

  > 系统调用时，堆栈切换（内核和用户的应用程序使用不同的堆栈）和特权级的切换，使得系统调用可以直接去访问控制硬件

* `CALL`和`RET`用于常规的调用，没有堆栈切换




# 第九章 输入输出设备

## 9.1 输入输出接口

是`CPU`和外设之间的中转站，它的基本功能如下：

* 数据缓冲  解决外设和`CPU`之间的速度差距
* 提供联络信息   协调同步数据交换过程
* 信号和信息格式的转换   数模模数转换  串并并串转换  电平转换
* 设备选择
* 中断管理
* 可编程功能

基本结构如下图：

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161204/152602724.png)

`IO`接口通过数据/控制/地址总线与`CPU`相连，同时IO接口又与外设相连 

与简单外设的连接

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161204/152950546.png)

与复杂外设的连接

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161204/153054736.png)

## 9.2 输入输出接口的编址

### 9.2.1 I/O端口

* I/O接口内部包含一组称为I/O端口的寄存器
* 每个端口都有自己的端口地址（端口号），方便CPU访问

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161204/153316922.png)

### 9.2 IO端口的编址

**I/O端口和存储器分开编址**

> `x86`体系采用这种方式编址

**I/O端口和存储器统一编址**

> `ARM`和`MIPS`采用这种方式编址

#### I/O指令说明

IN指令格式：IN AC,PORT

操作：将外设端口的内容输入到AL或者AX



OUT指令格式：OUT PORT,AC

操作：把AX或者AL的内容输出到外设端口

> 间接寻址需要将地址放入DX寄存器中

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161204/154110580.png)

### 9.2.3 统一编址和分开编址的特点

**统一编址优点：**

* 可以用访问存储器的指令来访问I/O端口，不用额外的设计访问I/O端口的指令
* 可以将IO操作和访问存储器的操作设计为同一套的控制逻辑，减少CPU硬件上电路的复杂度

**统一编址缺点：**

* 因为IO端口占用了一部分的存储器的地址，使得存储地址空间变短

## 9.3 输入输出的控制方式

### 9.3.1 IO的控制方式

1. 程序控制方式
2. 中断控制方式
3. 直接存储器访问方式（DMA）

### 9.3.2 程序控制方式

**无条件传送方式**

* 假定外设已经准备好
* CPU直接使用指令与外设传送数据
* 不查询外设的工作状态

> 控制简单，但是不能保证数据传送的可靠，只适用于简单的外设操作

**程序查询传送方式**

* CPU通过执行一段程序不断查询外设的工作状态
* 在外设准备就绪的时候才进行数据传输

> 数据传送可靠，但是查询外设的状态花费了大量的时间

> 共同的优缺点：对外设的要求低，操作流程清晰

程序查询方式的过程：

输出过程：

1. CPU执行指令，将控制字写入接口的控制寄存器，设置接口的工作模式（比如时钟频率）
2. CPU执行指令，将数据写到接口的“输出缓冲寄存器”
3. 接口将数据发到“并行数据输出”的信号线上，并将“输出准备好”的信号置为有效
4. 外设发现“输出准备好”的信号后，会从并行输出信号线上接受数据，并将“输出回答”信号置为有效
5. 接口发现“输出回答”信号有效后，将状态寄存器中的“输出缓冲空”置为有效
6. 在这个过程中，CPU反复执行指令从状态寄存器中读状态字，如果发现“输出缓冲空”，则开始下一个输出，继续输出新的数据

所以在这个输出过程中，一般是一条OUT指令，然后是几条逻辑运算指令去检查对应的状态位是否有效，还需要有一个跳转指令，决定是否要跳回去继续执行那条OUT指令，直到输出缓冲空有效，就执行下一个OUT指令

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161204/163809476.png)

输入过程类似，不同的就是外设给出“输入准备好”的信号

1. 系统初始化的时候，CPU执行指令，将控制字写入接口的控制寄存器，设置接口的工作模式
2. 外设将数据穿到并行数据信号线上，将“输入准备好”的信号置为有效
3. 当**接口**发现输入准备好的信号，则读取数据放入输入缓冲寄存器，并将状态寄存器中的相应的“输入缓冲满”置为有效，同时给出输入回答信号（阻止外设给出新的数据）
4. 上述过程中，CPU反复执行指令查询状态字，发现输入缓冲满，就取出数据，接口将输入回答置为无效，等待输入设备给出新的数据

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161204/163754778.png)

> 可以看出，在上述输入输出的过程中，CPU反复在查询接口中的状态寄存器中的状态字，浪费CPU的运算资源

### 9.3.3 程序控制方式的优缺点

**优点：对外设的要求低，操作流程清晰**

**缺点：用CPU来控制数据的传输，占用了CPU宝贵的运算资源**

## 9.4 中断控制方式

中断控制的过程与程序过程类似，不同就是不是CPU不断的查询状态字，而是当接口接收到数据（将“输入缓冲满”信号写入状态寄存器）或者当接口发出数据并受到外设的输出回答（将“输出缓冲空”信号写入状态寄存器），会由中断控制逻辑给CPU发出一个中断，让CPU读数据或者继续输入数据

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161204/170537516.png)

> 中断控制逻辑的电路连接到CPU的外部中断的接口上

**优点：**

* CPU与外设可以并行工作，提高了工作效率
* 外围设备具有申请服务的主动权（而不是CPU不断的查询，然后再给你服务）
* 一定程度上满足了IO处理的实时性要求

**缺点：**

* 外设和存储器之间的数据交换依旧需要CPU来承担，而且数据要经过CPU的通用寄存器作为中转，过程冗长，数据传输速度慢
* 通过中断的方式，进入和退出中断程序，需要额外的指令


### 9.4.1 外部中断的处理过程

外部中断也称硬件中断：由CPU外部的中断请求启动的中断

一般x86位外部中断提供两个引脚：NMI(非屏蔽中断)，INTR（可屏蔽中断）

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161204/191233115.png)

> 对于多个的可屏蔽的中断，加一个中断控制器，中断控制器再连接到CPU的可屏蔽中断的引脚上，同时中断控制器也有一些控制屏蔽和优先级的功能

**中断控制器的实例**

可编程中断控制器：PIC（Programmable Interrupt Controller）,例如`8259A`

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161204/191809086.png)

高级可编程中断控制器：APIC advanced  `82093AA`

在现代的PC机中都使用了APIC，而且集成在南桥芯片中，多核CPU之间的通讯和协同工作也是通过CPU里面的APIC

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161204/192540929.png)

**可屏蔽中断的完整执行过程：**

1. 外设发出中断请求信号
2. CPU执行完当前的指令，响应中端
3. CPU读取中断类型码
4. 保存现场，将当前的CS/IP/FLAGS，以及中断服务程序要使用的寄存器的内容压入堆栈
5. 清除IF和TF标志，关闭其他外设的中断响应（IF置为0）
6. 根据中断类型码去存储器取出新的CS/IP地址
7. 转入中断服务程序
8. 开放中断（TF置为1），允许其他优先级高的中断得到响应，这种情况也叫中断嵌套
9. IRET指令使旧的CS/IP/PSW值弹出堆栈进入寄存器，就是把保存现场的值全部弹回
10. 返回被中断的程序继续运行

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161204/194038525.png)

**中断嵌套**

* 当CPU执行中断服务程序时，发生了优先级更高的中断请求
* CPU响应优先级更高的中断，将正在处理的中断挂起
* CPU完成更高的中断请求后，逐级返回

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161204/194334695.png)

 ## 9.5 直接存储器访问的方式（DMA）

直接存储器访问，Direct Memory Access：

* 数据传输过程不需要CPU干预
* 由专门的硬件控制电路（DMA控制器，DMAC）控制，进行外设和存储器间的直接数据传输

DMAC的基本工作步骤，其中主模块接口是能够主动发出请求的设备

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161204/200605014.png)

其中，CPU设置DMAC内部配置寄存器的参数，一般包括：

* 源地址的初始值及传送时的地址增减方式（即从哪里传送数据）
* 目的地址的初始值及传送时的地址增减方式（即传送到哪里去）
* 待传送数据的长度

举个例子，从外设到内存的传送：

1. 源地址设置为某IO端口，传送时不变
2. 目的地址设置为存储器的某个地址，传送时递增
3. “待传送数据的长度”根据需要设置，可以不设置（输入可能不知道需要传送的数据的大小）


> 随着技术的发展，有些外设对数据传输的数据的要求很高，所有的IO接口共享一个DMAC不能满足其要求，于是出现了某些IO接口自带DMAC（显示器）
>
> 共享的DMAC可以提供内存到内存的传输数据的服务（大量文件的复制）




# 算术逻辑单元

`计算机组成`

## 门电路的基本原理

###晶体管（transistor）
现代电路中一般使用`MOS(Metal-Oxide-Semeconductor)`晶体管，分为

* **`N`型MOS晶体管**  当`Gate`端为高电平时，`MOS`管导通 
* **`P`型MOS晶体管**  当`Gate`端为低电平时，`MOS`管导通 

 ![mark](http://ogzrgstml.bkt.clouddn.com/blog/20170301/154802440.png)

### 基础门电路的实现

> * 非门   一个N型和一个P型晶体管构成
> * 与门   市场上一般用与非门代替与门，因为与非门的制造更为简单
> * 或门
> * 异或门

 ![mark](http://ogzrgstml.bkt.clouddn.com/blog/20170301/154822638.png)

 ![mark](http://ogzrgstml.bkt.clouddn.com/blog/20170301/154834424.png)



## 寄存器的基本原理

使用D触发器来存储一个基本的Bit，时钟的上升沿触发
D触发器的几个属性，CP时钟频率，上升沿前后很短时间数据要稳定，前为`setup`，后为`Hold`，还有一个延迟时间，叫做`CLK-TO-Q`时间，即将数据从输入端传送到输出的时间

如此，32个D触发器就可以构成一个32位的寄存器，CP是同步的。

## 逻辑运算的实现

逻辑运算与算术运算都是通过CPU中一个叫`ALU(Arithmetical Logical Unit)`的部件完成的,例如在`MIPS`指令中的逻辑运算指令:`and $rs $rt $rd`

两个32位操作数的每一位分别连接上相应的门电路，得出所有的逻辑运算结果，然后通过指令中的操作码`OPCode`选择相应的操作结果输出，通过`CPU`内部总线将数据传输到相应的寄存器中。

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20170301/154851096.png)

## 加法和减法的实现

### 半加器

半加器的输出S就是输入A与B的异或，进位C就是A与B

 ![mark](http://ogzrgstml.bkt.clouddn.com/blog/20170301/154859992.png)

### 全加器

全加器由两个半加器构成，输出S不仅取决与输入A和B，还要看进位输入$C_{in}$

$C_{in} = (A \oplus B) \oplus C_{in}$

$C_{out} = (A · B) + C_{in} · (A \oplus B) $

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20170301/154908929.png)

### 加法运算的实现

**行波进位加法器(RCA)**

这里用一个32位的行波进位加法器为例，将32个全加器串联起来，低位的$C_{out}$连接上高位的$C_{in}$

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20170301/154920389.png)

**溢出的判断** 

> 溢出的概念是针对有符号位的操作数提出的

单符号判断法：

最高有效位有进位而符号位无进位时，上溢
最高有效位无进位而符号位有进位时，下溢

> 在电路上可以用最高有效位和符号位的进位异或来判断加法溢出

MIPS指令系统提供了两套指令
一个是add rd rt rs  产生溢出时做异常处理
一个是addu rd rt rs 产生溢出是不做异常处理，用于无符号的加法。

X86指令体系则不同，如果操作数是有符号的，产生溢出，则会将Flag寄存器里面的溢出标志位`OF`置为1

### 减法运算

减法转换为加法来运算

```
A-B = A + (-B) = A + (~B+1)
```

相当于`A-B`的操作转换为A加上B的补码，于是在电路中，只需要对加法器进行一点小的改造就能实现减法器，我们可以在加法器的两个操作数输入端接入一个2选1选择器，如果是减法操作则对操作数取反加1（也是我们通常说的求补操作）

当执行加法时，`sub-mode`的值为0，$C_0$为0，同时B操作数从左边的线路进入行波进位加法器

当执行减法时，`sub-mode`的值为1，$C_0$为1，同时B操作数经过右边的线路，所有位取反，$C_0$为1就是取反后加一

这样就完成了加法到减法的转换

 ![mark](http://ogzrgstml.bkt.clouddn.com/blog/20170301/154926478.png)

### 加法器的优化
**超前进位加法器(LCA)**

行波进位加法器有一个缺点就是每一个单独的全加器即使有了两个操作数输入，但是仍然需要等待上一个全加器的进位输出才能产生结果，即高位的运算必须等待低位的进位输出，于是就有很大的延迟。

如果将一个门电路的延迟时间设为T，则对于N位操作数的加法，延迟时间则为`(2n+1)T`

全加器进位输出$C_{i+1}$等于

$$C_{i+1} = (A_i · B_i) + (A_i · C_i) + (B_i · C_i)\\=(A_i · B_i) + (A_i + B_i) · C_i$$

如果设 $G_i = A_i · B_i\quad P_i = A_i + B_i$
$$ C_{i+1} = G_i + P_i·C_i $$
所以

$C_1 = G_0 + P_0·C_0$

$C_2 = G_1 + P_1 · C_1 = G_1 + P_1·G_0 + P_1·P_0·C_0$

这样就可以不用等待低位的进位输出，直接并行得到任何一位的运算结果。

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20170301/154947574.png)

通过图中可以看到，计算$C_{i+1}$延迟固定为三级门电路，则计算出最后一位$C_{out}$延迟固定为4个门电路，但是如果加法器位数过大，则会使最后一位的电路变得相当复杂，那么现代计算机中的加法器是如何解决这个问题的呢？

一个32位的加法器，通常做法是用4个8位的超前进位加法器串起来，这样就避免了超前进位加法器位数过宽带来的电路结构的复杂，接下来我们比较一下这三种模式的加法器。

照样以一个32的加法器为例，假设一个门电路的延迟`T`为0.02ns

|         | 行波进位加法器 | 超前进位加法器 | 超前行波混合加法器 |
| :-----: | :-----: | :-----: | :-------: |
|   门延迟   |   65T   |   4T    |    13T    |
|  电路结构   |   简单    |   复杂    |    中等     |
|  门延迟时间  |  1.3ns  | 0.08ns  |  0.26ns   |
| CPU理想频率 | 769MHz  | 12.5GHz |  3.84GHz  |

我自己的笔记本的CPU的频率是`2.6GHz`，当然，表中的数据只是一种理想状态，只考虑了门延迟，没有考虑电路中其他的因素，但是也可以看出，行波进位加法器的效率的低下。

# 指令系统

## 1. 指令概述

指令系统总的来说可以分为两种：

* CISC(Complex Instructor Set Computer)，复杂指令系统计算机
* RISC(Reduced Instructor Set Computer)，精简指令系统计算机

`CISC`指令集计算机体系架构中的代表架构就是`x86`，PC机基本都是这个架构

`RISC`指令集计算机体系架构中的代表架构分别是`ARM`和`MIPS`，现在的移动终端设备基本都是用的`ARM`架构的处理器，无论是安卓上的高通骁龙`Snapdragon`还是联发科的`MTK`，或者苹果最新发布的`A10`处理器，都是买的`ARM`的架构，然后研发的，而`MIPS`停留在一些嵌入式小众市场，`ARM`架构是商业化最成功的`RISC`指令集计算机体系结构，而`MIPS`则偏向学院派发展风格，缺少商业驱动，接下来主要介绍`x86`和`MIPS`体系结构

但是无论是怎样的一个指令结构，指令都可以按功能简单的分为三类：

| 指令类型  | 运算类指令               | 传送类指令                   | 转移类指令              |
| ----- | ------------------- | ----------------------- | ------------------ |
| 指令举例  | ADD R,M             | LOAD R,M \| STORE M,R   | JMP L              |
| 指令的功能 | 将R中的内容与M中的内容相加后放入R中 | 将M中的内容装载入R中 \| 将R中内容存入M | 无条件的将下一条执行的指令转移到L处 |

其中`R`是寄存器，`M`是存储器，当然，每一个指令系统都有其固定的格式，对应相应的机器码，这里我们可以举一个简单的例子，假如你要设计的指令定长，并且为两个字节，可以把第一个字节的前4位作为操作码，用来识别指令类型，第一个字节的后四位作为寄存器编号，第二字节作为存储单元的地址

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161127/191524857.png)

那么`add R2,[9]`这个加法指令则可以表示为机器码`00010010 00001001`，意思是将寄存器`R2`中的内容与存储器地址为`00001001`中内容相加，结果存进`R2`寄存器中

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161127/191729604.png)

类似的，也可以按照某个规则去规定其他指令的机器码，

## 2. x86体系结构

目前`x86`体系主要分为16位，32位和64位三大类，在`Intel`的`CPU`发展史中，8086是第一个`x86`架构的处理器，在这之

前`Intel CPU` 系列，最初是 4 位微处理器`4004`，然后到到 8 位微处理器的`8008` ，再到 8 位微处理器`8080`,`Intel 8086` 为16位`CPU`，而因为在`8086`之前的 CPU 都是 8 位 CPU，这样也就造成了很多的外设也只支持 8 位，因此`Intel`紧接着就推出了 8 位的`8088 CPU`，因此`Intel 8088`也就可以看做是`8086`的 8 位版本。

在`8088 CPU`之后，`Intel` 又推出了`80186`，`80286`，这两款`CPU`均是16位`CPU`，而对于`80186`来说，其与`8086`的区别可以简单的看做是`80186`多了几条指令而已，而`80286`则不同，`80286`的地址总线数目有了变化，在`8086,8088,80186` 上，CPU 的地址总线都是 20 根，即可最大寻址$2^{20}$即达到 1MB 的寻址能力，而对于`80286 CPU`来说，其地址总线数目达到了 24 根，从而最大寻址能力为$2^{24}$即 16MB，由于支持更多的物理内存寻址，因此 `80286`便开始成为了多任务，多用户系统的核心。

而后来，`Intel`又推出了`80386`，`80386`为 32 位微处理器，`Intel 80x86`家族的 32 位微处理器始于`80386`，同时 `80386`也完全兼容先前的`x86`架构的CPU，并且`80386`全面支持 32 位数据类型和 32 位操作，并且其数据总线根数和地址总线根数均达到了32根，从而可以最大物理寻址为$2^{32}$即4GB。

而之后的`80486`也是 32 位微处理器，而后又出来了`Pentium`和`Pentium Pro`等等第五代微处理器，这些处理器虽然也是 32 位微处理器，但是他们的数据总线和地址总线都有所扩展，比如`Pentium`的数据总线达到64位，而`Pentium Pro`的地址总线位数达到了36位 。

![mark](http://ogzrgstml.bkt.clouddn.com/blog/20161127/180611726.png)

以上就是以`Intel`为代表的`x86`CPU的历史，这里我们以最早推出的16位`x86`体系的`Intel 8086`为例子来了解`x86`体系架构。

### Intel 8086的主要特点

* 内部的通用寄存器为16位，即能处理16位数据，也能处理8位数据
* 对外有16根数据总线和20根地址总线，可以寻址的内存空间为`1MB`，也就是$2^{20}$
* 因为数据总线只有16根，所以物理地址的形成采用**段加偏移**的方式

 ![mark](http://ogzrgstml.bkt.clouddn.com/blog/20170301/155433828.png)

### Intel 8086的寄存器模型

到底寄存器是什么？其实很简单，寄存器就是个存储信息的单元或者说是器件又或者说是容器而已，和内存是一个信息，就是用来存放数据和信息，不同的只是寄存器在CPU内部，而内存在CPU外部。

8086的寄存器按功能分为4种：

* 通用寄存器
* 指令指针寄存器
* 标志寄存器
* 段寄存器



## 3. MIPS体系结构

### 3.1 MIPS的设计指导思想

`MIPS`全称：Microprocessor Without Interlocked Piped Stages，其关注点为减少指令的类型，降低指令的复杂度

> A Simple CPU Is A Faster CPU

### 3.2 MIPS指令的特点

* **固定的指令长度**  `32bit`，一个字，简化了从存储器取指令，因为不需要像`X86`那样去判断每条指令的长度
* **简单的寻址模式**  简化了从存储器取操作数，不提供像`X86`那样复杂多样的寻址，加快了CPU从存储器取操作数的速度
* **指令数量少，功能简单**  一个指令只完成一个操作，简化指令的执行过程，不像`X86`的指令一样完成一个复杂的功能
* **只允许Load和Store指令访问存储器**  不提供类似`X86`中`ADD AX,[3000H]`这种让算术指令访问存储器的操作，因为访问存储器是一个比较复杂的操作，这种限制可以让算术指令的实现变得简单
* **需要有优秀的编译器支持**  `MIPS`指令简化的特点使得编程人员的工作变得困难，所以需要一个优秀的编译器

